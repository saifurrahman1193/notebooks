# DFS
## DFS Simultion 1
![alt text](assets/dfs.png)

## DFS Simultion 2
![alt text](assets/dfs_2.png)
![alt text](assets/dfs_2_2.png)

## DFS Simultion 3 
### Disconnected Graph
![alt text](assets/dfs_3.png)

## DFS Simultion 4 
### Disconnected Graph : needs to restart from the unvisited disconnected node
![alt text](assets/dfs_4.png)


## DFS Simultion 5 
### Disconnected Graph : needs to restart from the unvisited disconnected node
![alt text](assets/dfs_5.png)



# BFS
## BFS Simultion 1
![alt text](assets/bfs.png)

## BFS Simultion 2
![alt text](assets/bfs_2.png)
![alt text](assets/bfs_2_2.png)

## BFS Simultion 3
![alt text](assets/bfs_3.png)
![alt text](assets/bfs_3_1.png)
![alt text](assets/bfs_3_2.png)
![alt text](assets/bfs_3_3.png)
![alt text](assets/bfs_3_4.png)

## BFS Simultion 4
### Disconnected Graph : needs to restart from the unvisited disconnected node


---
# Comparisons : DFS, BFS, DLS, IDS, UCS 
---

| Feature / Algorithm | **DFS**                        | **BFS**                                  | **DLS**                     | **IDS**                                   | **UCS**                                       |
| ------------------- | ------------------------------ | ---------------------------------------- | --------------------------- | ----------------------------------------- | --------------------------------------------- |
| **Formula**         | DFS = Stack (LIFO)             | BFS = Queue (FIFO)                       | DLS = DFS + Depth Limit     | IDS = Repeated DLS with increasing limit  | UCS = Priority Queue + Lowest Path Cost First |
| **Data Structure**  | Stack (explicit or recursion)  | Queue                                    | Stack + Depth Counter       | Stack + Depth Limit Loop                  | Priority Queue (Min-Heap)                     |
| **Prioritizes**     | Depth first                    | Shallowest depth                         | Depth until limit           | Shallowest depth via repeated DFS         | Lowest total path cost                        |
| **Uses Weights?**   | ❌                              | ❌                                        | ❌                           | ❌                                         | ✅                                             |
| **Completeness**    | No (may loop forever)          | Yes (if finite graph)                    | No (if target beyond limit) | Yes (if finite graph)                     | Yes (positive weights)                        |
| **Optimality**      | No                             | Yes (unweighted)                         | No                          | Yes (unweighted)                          | Yes                                           |
| **Memory Use**      | Low                            | High                                     | Low                         | Low                                       | Moderate                                      |
| **Notes**           | Can get stuck in deep branches | Finds shortest path in unweighted graphs | Avoids going too deep       | Combines BFS completeness with DFS memory | Finds cheapest path in weighted graphs        |


---


Alright — let’s break down the **performance & analysis** for the five search algorithms (DFS, BFS, DLS, IDS, UCS) in terms of **time complexity, space complexity, completeness, and optimality**.

---

| **Algorithm** | **Time Complexity**                                                           | **Space Complexity**                                              | **Completeness**                       | **Optimality** | **When to Use**                                         |
| ------------- | ----------------------------------------------------------------------------- | ----------------------------------------------------------------- | -------------------------------------- | -------------- | ------------------------------------------------------- |
| **DFS**       | $O(b^m)$ — explores deep first, where $b$ = branching factor, $m$ = max depth | $O(bm)$ — only stores current path                                | ❌ (may loop forever if infinite depth) | ❌              | When memory is very limited and solution is likely deep |
| **BFS**       | $O(b^d)$ — explores shallow first, $d$ = depth of solution                    | $O(b^d)$ — stores all frontier nodes                              | ✅ (if finite graph)                    | ✅ (unweighted) | When you need shortest path in an unweighted graph      |
| **DLS**       | $O(b^l)$ — limited by depth limit $l$                                         | $O(bl)$                                                           | ❌ (if target deeper than limit)        | ❌              | When solution is within known depth limit               |
| **IDS**       | $O(b^d)$ — repeats DFS up to depth $d$                                        | $O(bd)$                                                           | ✅ (if finite graph)                    | ✅ (unweighted) | When depth unknown but memory efficiency needed         |
| **UCS**       | $O(b^{1 + \lfloor C^*/\epsilon \rfloor})$ — expands least-cost node first     | $O(b^{1 + \lfloor C^*/\epsilon \rfloor})$ — stores frontier in PQ | ✅ (if all costs ≥ 0)                   | ✅              | When finding least-cost path in weighted graphs         |

---

**Legend**:

* $b$ = branching factor (average number of children per node)
* $d$ = depth of shallowest goal node
* $m$ = maximum depth of graph
* $l$ = depth limit (DLS)
* $C^*$ = cost of optimal solution
* $\epsilon$ = minimum edge cost

---
