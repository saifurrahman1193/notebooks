# DFS

    - depth first search
    - uses stack (LIFO)
    - goes deep into the graph before backtracking
    - can get stuck in deep branches
    - not guaranteed to find the shortest path
    - not complete (may loop forever)
    - low memory use
    - can be implemented using recursion or an explicit stack
    - can be used for pathfinding, topological sorting, and cycle detection

## DFS performance analysis
- Time Complexity: $O(b^m)$, where $b$ is the branching factor and $m$ is the maximum depth of the graph.
- Space Complexity: $O(b^m)$, where $b$ is the branching factor and $m$ is the maximum depth of the graph.
- Completeness: No (may loop forever).
- Optimality: No (may not find the shortest path).
- When to Use: When memory is very limited and the solution is likely deep.





## DFS Simultion 1
![alt text](assets/dfs.png)

## DFS Simultion 2
![alt text](assets/dfs_2.png)
![alt text](assets/dfs_2_2.png)

## DFS Simultion 3 
### Disconnected Graph
![alt text](assets/dfs_3.png)

## DFS Simultion 4 
### Disconnected Graph : needs to restart from the unvisited disconnected node
![alt text](assets/dfs_4.png)


## DFS Simultion 5 
### Disconnected Graph : needs to restart from the unvisited disconnected node
![alt text](assets/dfs_5.png)



# BFS

    - Breadth first search
    - level by level search
    - uses queue (FIFO)
    - finds the shallowest solution first
    - guaranteed to find the shortest path in unweighted graphs
    - complete (if the graph is finite)
    - high memory use
    - can be used for pathfinding, shortest path in unweighted graphs, and level-order traversal
    - can be implemented using an explicit queue
    - can be used for finding connected components in a graph

## BFS performance analysis

- **Time Complexity**: $O(b^d)$, where $b$ is the branching factor and $d$ is the depth of the shallowest goal node.
- **Space Complexity**: $O(b^d)$, where $b$ is the branching factor and $d$ is the depth of the shallowest goal node.
- **Completeness**: Yes (if the branching factor is finite and the shallowest goal node is at finite depth).
- **Optimality**: Yes (if all actions have the same cost or path cost is a nondecreasing function of depth).
- **When to Use**: When you need the shortest path in unweighted graphs or when the solution is likely shallow.

---

## **Key Points**

### **1. What BFS does**

* Expands the **root node first**.
* Then **all nodes at depth 1**.
* Then **all nodes at depth 2**, etc.
* Works **level-by-level** in the search tree.
* Implemented using a **FIFO queue** for the frontier.
* Applies **goal test** when a node is *generated*, not when expanded.

---

### **2. Completeness**

* **Complete** if:

  * Branching factor $b$ is finite.
  * The shallowest goal node is at finite depth $d$.
* BFS will find the **shallowest depth goal**.

---

### **3. Optimality**

* **Optimal** only if:

  * All actions have the **same cost**, OR
  * Path cost is a **nondecreasing function** of depth.
* Otherwise, the shallowest path might not be cheapest.

---

### **4. Complexity**

* **Time complexity**: $O(b^d)$
  (where $b$ = branching factor, $d$ = depth of shallowest goal)
* **Space complexity**: $O(b^d)$
  (storing all nodes in memory — both frontier and explored set)
* **Memory can be a bigger problem than time** for BFS.

Example table from Figure 3.13 (assuming $b = 10$, 1M nodes/sec, 1000 bytes/node):

| Depth | Nodes     | Time    | Memory |
| ----- | --------- | ------- | ------ |
| 6     | $10^6$    | 1.1 sec | 1 GB   |
| 12    | $10^{12}$ | 13 days | 1 PB   |
| 16    | $10^{16}$ | 350 yrs | 10 EB  |

---

### **5. Takeaways**

* BFS **guarantees the shallowest solution**.
* But **huge memory usage** makes it impractical for large $b$ or $d$.
* **Time** also grows exponentially.
* For **unweighted graphs**, BFS is optimal; for **weighted graphs**, use UCS or A\*.

---


## BFS Simultion 1
![alt text](assets/bfs.png)

## BFS Simultion 2
![alt text](assets/bfs_2.png)
![alt text](assets/bfs_2_2.png)

## BFS Simultion 3
![alt text](assets/bfs_3.png)
![alt text](assets/bfs_3_1.png)
![alt text](assets/bfs_3_2.png)
![alt text](assets/bfs_3_3.png)
![alt text](assets/bfs_3_4.png)

## BFS Simultion 4
### Disconnected Graph : needs to restart from the unvisited disconnected node


# DLS

    - Depth limited search
    - depth first search with a depth limit
    - uses stack (LIFO)
    - avoids going too deep
    - not guaranteed to find the shortest path
    - not complete (if the target is beyond the depth limit)
    - low memory use
    - can be used for pathfinding, topological sorting, and cycle detection with a depth limit

## DLS performance analysis
- **Time Complexity**: $O(b^l)$, where $b$ is the branching factor and $l$ is the depth limit.
- **Space Complexity**: $O(bl)$, where $b$ is the branching factor and $l$ is the depth limit.
- **Completeness**: Yes (if the depth limit $l$ is greater than or equal to the depth of the shallowest goal node). 
- **Optimality**: No (may not find the shortest path).
- **When to Use**: When you know the solution is within a certain depth limit and you want to avoid going too deep.
- **Notes**: DLS is useful for large search spaces where you want to limit the depth of the search to avoid excessive memory use or infinite loops.
- **Example**: DLS can be used in scenarios like searching for a file in a directory structure where you know the file is not deeper than a certain level.
- **Limitations**: If the target node is deeper than the depth limit, DLS will not find it, and it may miss solutions that are deeper than the limit.
- **Implementation**: DLS can be implemented using a recursive function or an explicit stack with a depth counter.
- **Advantages**: Low memory usage compared to BFS, and it can be more efficient than DFS in certain scenarios where the solution is known to be within a specific depth.

# IDS

    - Iterative deepening search
    - combines the benefits of DFS and BFS
    - uses stack (LIFO) with increasing depth limits
    - finds the shallowest solution first
    - complete (if the graph is finite)
    - low memory use
    - can be used for pathfinding, topological sorting, and cycle detection with increasing depth limit
## How IDS works
  - IDS performs DFS repeatedly with increasing depth limits.
  - It searches shallowest nodes first, counting depth, not the actual cost of edges.
  

## IDS performance analysis
- **Time Complexity**: $O(b^d)$, where $b$ is the branching factor and $d$ is the depth of the shallowest goal node. This is because IDS performs a series of depth-limited searches, each with increasing depth limits, until it finds the goal.
- **Space Complexity**: $O(bd)$, where $b$ is the branching factor and $d$ is the depth of the shallowest goal node. This is because IDS only needs to store the nodes in the current depth-limited search, which is similar to DFS.
- **Completeness**: Yes (if the branching factor is finite and the shallowest goal node is at finite depth). IDS will eventually reach all nodes at depth $d$.
- **Optimality**: Yes (if all edge costs are equal). IDS will find the shallowest goal node, which is optimal in unweighted graphs.
- **When to Use**: When you need the benefits of both DFS and BFS, such as when the depth of the solution is unknown, and you want to avoid the high memory usage of BFS while still ensuring completeness.
- **Notes**: IDS is particularly useful in scenarios where the search space is large, and the solution is likely to be shallow. It combines the low memory usage of DFS with the completeness of BFS.
- **Example**: IDS can be used in scenarios like searching for a solution in a puzzle where the depth of the solution is unknown, and you want to ensure that you find the shallowest solution without excessive memory use.
- **Limitations**: IDS can be slower than BFS in some cases because it repeatedly explores nodes at shallower depths, but it is more memory-efficient.
- **Implementation**: IDS can be implemented using a loop that repeatedly calls a depth-limited search function with increasing depth limits until the goal is found.


---

# IDS (Iterative Deepening Search) is optimal only if all edge costs are equal

---

## 1. What “optimal” means

* **Optimal**: The search finds a **least-cost path** from start to goal.
* In a graph, the **cost** is the sum of edge costs along the path.

---

## 2. How IDS works

* IDS performs **DFS repeatedly with increasing depth limits**.
* It searches **shallowest nodes first**, counting **depth**, **not the actual cost of edges**.

---

## 3. When edge costs are **equal**

* Suppose **every step has the same cost** (e.g., 1).
* Then **depth = total cost**, because each step adds the same cost.
* ✅ The **shallowest goal** found by IDS is also the **least-cost goal**.
* **Example:**

```
Depth 0: A
Depth 1: A → B
Depth 2: A → B → G (goal)
```

* All edges cost 1 → total cost = depth = 2 → optimal.

---

## 4. When edge costs are **unequal**

* Suppose edges have different costs:

```
       A
     /   \
   B(1)   C(5)
    |      |
    D(1)   G(1)
    |
    G(1)
```

* IDS finds **C → G** first at depth 2 (total cost = 5 + 1 = 6)
* But **A → B → D → G** has total cost = 1 + 1 + 1 = 3 → optimal path
* ❌ IDS does **not consider actual costs**, only depth → not optimal.

---

### ✅ Summary Table

| Edge costs            | IDS Optimal? | Reason                             |
| --------------------- | ------------ | ---------------------------------- |
| Equal (uniform)       | Yes          | Shallowest depth = least-cost path |
| Unequal (non-uniform) | No           | Depth doesn’t reflect total cost   |

---



# UCS

    - Uniform cost search
    - uses priority queue (min-heap)
    - finds the cheapest path first
    - complete (if the graph is finite and all edge costs are positive)
    - optimal (finds the least-cost path)
    - moderate memory use
    - can be used for pathfinding in weighted graphs, shortest path in graphs with varying edge costs, and network routing
    - can be implemented using a priority queue to always expand the least-cost node first
    - can be used for finding the least-cost path in graphs with varying edge costs
    - can be used for network routing algorithms like Dijkstra's algorithm

## UCS performance analysis

- **Time Complexity**: exponential
- **Space Complexity**: exponential
- **Completeness**: Yes (if all edge costs are positive and the graph is finite). UCS will eventually explore all nodes at depth $d$.
- **Optimality**: Yes (if all edge costs are positive). UCS will find the least-cost path to the goal node.
- **When to Use**: When you need to find the least-cost path in weighted graphs or when the edge costs vary. UCS is particularly useful in scenarios where the path cost is a critical factor, such as in network routing or logistics.
- **Notes**: UCS is similar to Dijkstra's algorithm and is often used in scenarios where the cost of the path is more important than the depth of the solution. It guarantees that the least-cost path is found, making it suitable for many real-world applications.
- **Example**: UCS can be used in scenarios like finding the shortest path in a road network where different roads have different travel costs, or in logistics where the cost of transporting goods varies based on distance or other factors.
- **Limitations**: UCS can be slower than BFS in some cases because it explores nodes based on their path cost rather than depth, but it is more efficient in finding the least-cost path in weighted graphs.
- **Implementation**: UCS can be implemented using a priority queue (min-heap) to always expand the least-cost node first, ensuring that the search is efficient and optimal.
- **Advantages**: UCS is optimal for finding the least-cost path in weighted graphs, and it is complete as long as the edge costs are positive. It balances the need for optimality with reasonable memory usage compared to BFS.
- **Disadvantages**: UCS can have high time complexity in graphs with large branching factors or deep solutions, and it may require significant memory to store all nodes in the priority queue.



---
# Comparisons : DFS, BFS, DLS, IDS, UCS 
---

| Feature / Algorithm | **DFS**                        | **BFS**                                  | **DLS**                     | **IDS**                                   | **UCS**                                       |
| ------------------- | ------------------------------ | ---------------------------------------- | --------------------------- | ----------------------------------------- | --------------------------------------------- |
| **Formula**         | DFS = Stack (LIFO)             | BFS = Queue (FIFO)                       | DLS = DFS + Depth Limit     | IDS = Repeated DLS with increasing limit  | UCS = Priority Queue + Lowest Path Cost First |
| **Data Structure**  | Stack (explicit or recursion)  | Queue                                    | Stack + Depth Counter       | Stack + Depth Limit Loop                  | Priority Queue (Min-Heap)                     |
| **Prioritizes**     | Depth first                    | Shallowest depth                         | Depth until limit           | Shallowest depth via repeated DFS         | Lowest total path cost                        |
| **Uses Weights?**   | ❌                              | ❌                                        | ❌                           | ❌                                         | ✅                                             |
| **Completeness**    | No (may loop forever)          | Yes (if finite graph)                    | No (if target beyond limit) | Yes (if finite graph)                     | Yes (positive weights)                        |
| **Optimality**      | No                             | Yes (unweighted)                         | No                          | Yes (unweighted)                          | Yes                                           |
| **Memory Use**      | Low                            | High                                     | Low                         | Low                                       | Moderate                                      |
| **Notes**           | Can get stuck in deep branches | Finds shortest path in unweighted graphs | Avoids going too deep       | Combines BFS completeness with DFS memory | Finds cheapest path in weighted graphs        |


---


Alright — let’s break down the **performance & analysis** for the five search algorithms (DFS, BFS, DLS, IDS, UCS) in terms of **time complexity, space complexity, completeness, and optimality**.

---

| **Criteria**         | **DFS**                                                                       | **BFS**                                                                       | **DLS**                                                                           | **IDS**                                    | **UCS**                            |
| -------------------- | ----------------------------------------------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------------------------- | ------------------------------------------ | ---------------------------------- |
| **Time Complexity**  | $O(b^m)$ — explores deep first, where $b$ = branching factor, $m$ = max depth | $O(b^s)$ — explores shallow first, $s$ = depth of shallowest goal/depths/node | $O(b^l)$ — limited by depth limit $l$, $s$ = depth of shallowest goal/depths/node | $O(b^s)$ — repeats DFS up to depth $d$     | Exponential                        |
| **Space Complexity** | $O(b^m)$                                                                      | $O(b^s)$                                                                      | $O(bl)$                                                                           | $O(bs)$                                    | Exponential                        |
| **Completeness**     | NO                                                                            | YES                                                                           | YES (If l >= S)                                                                   | YES                                        | YES                                |
| **Optimality**       | NO                                                                            | YES                                                                           | NO                                                                                | YES (if all edge costs are equal)          | YES                                |
| **When to Use**      | Memory is very limited and solution is likely deep                            | Need shortest path in unweighted graph                                        | Solution within known depth limit                                                 | Depth unknown but memory efficiency needed | Least-cost path in weighted graphs |

---

**Legend**:

* $b$ = branching factor (average number of children per node)
* $d$ = depth of shallowest goal node
* $m$ = maximum depth of graph
* $l$ = depth limit (DLS)
* $C^*$ = cost of optimal solution
* $\epsilon$ = minimum edge cost

---


