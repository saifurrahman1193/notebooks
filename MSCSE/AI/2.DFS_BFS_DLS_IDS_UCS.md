# DFS

    - depth first search
    - uses stack (LIFO)
    - goes deep into the graph before backtracking
    - can get stuck in deep branches
    - not guaranteed to find the shortest path
    - not complete (may loop forever)
    - low memory use
    - can be implemented using recursion or an explicit stack
    - can be used for pathfinding, topological sorting, and cycle detection

## DFS performance analysis
- Time Complexity: $O(b^m)$, where $b$ is the branching factor and $m$ is the maximum depth of the graph.
- Space Complexity: $O(b^m)$, where $b$ is the branching factor and $m$ is the maximum depth of the graph.
- Completeness: No (may loop forever).
- Optimality: No (may not find the shortest path).
- When to Use: When memory is very limited and the solution is likely deep.





## DFS Simultion 1
![alt text](assets/dfs.png)

## DFS Simultion 2
![alt text](assets/dfs_2.png)
![alt text](assets/dfs_2_2.png)

## DFS Simultion 3 
### Disconnected Graph
![alt text](assets/dfs_3.png)

## DFS Simultion 4 
### Disconnected Graph : needs to restart from the unvisited disconnected node
![alt text](assets/dfs_4.png)


## DFS Simultion 5 
### Disconnected Graph : needs to restart from the unvisited disconnected node
![alt text](assets/dfs_5.png)



# BFS

    - Breadth first search
    - level by level search
    - uses queue (FIFO)
    - finds the shallowest solution first
    - guaranteed to find the shortest path in unweighted graphs
    - complete (if the graph is finite)
    - high memory use
    - can be used for pathfinding, shortest path in unweighted graphs, and level-order traversal
    - can be implemented using an explicit queue
    - can be used for finding connected components in a graph

## BFS performance analysis

- **Time Complexity**: $O(b^d)$, where $b$ is the branching factor and $d$ is the depth of the shallowest goal node.
- **Space Complexity**: $O(b^d)$, where $b$ is the branching factor and $d$ is the depth of the shallowest goal node.
- **Completeness**: Yes (if the branching factor is finite and the shallowest goal node is at finite depth).
- **Optimality**: Yes (if all actions have the same cost or path cost is a nondecreasing function of depth).
- **When to Use**: When you need the shortest path in unweighted graphs or when the solution is likely shallow.

---

## **Key Points**

### **1. What BFS does**

* Expands the **root node first**.
* Then **all nodes at depth 1**.
* Then **all nodes at depth 2**, etc.
* Works **level-by-level** in the search tree.
* Implemented using a **FIFO queue** for the frontier.
* Applies **goal test** when a node is *generated*, not when expanded.

---

### **2. Completeness**

* **Complete** if:

  * Branching factor $b$ is finite.
  * The shallowest goal node is at finite depth $d$.
* BFS will find the **shallowest depth goal**.

---

### **3. Optimality**

* **Optimal** only if:

  * All actions have the **same cost**, OR
  * Path cost is a **nondecreasing function** of depth.
* Otherwise, the shallowest path might not be cheapest.

---

### **4. Complexity**

* **Time complexity**: $O(b^d)$
  (where $b$ = branching factor, $d$ = depth of shallowest goal)
* **Space complexity**: $O(b^d)$
  (storing all nodes in memory — both frontier and explored set)
* **Memory can be a bigger problem than time** for BFS.

Example table from Figure 3.13 (assuming $b = 10$, 1M nodes/sec, 1000 bytes/node):

| Depth | Nodes     | Time    | Memory |
| ----- | --------- | ------- | ------ |
| 6     | $10^6$    | 1.1 sec | 1 GB   |
| 12    | $10^{12}$ | 13 days | 1 PB   |
| 16    | $10^{16}$ | 350 yrs | 10 EB  |

---

### **5. Takeaways**

* BFS **guarantees the shallowest solution**.
* But **huge memory usage** makes it impractical for large $b$ or $d$.
* **Time** also grows exponentially.
* For **unweighted graphs**, BFS is optimal; for **weighted graphs**, use UCS or A\*.

---


## BFS Simultion 1
![alt text](assets/bfs.png)

## BFS Simultion 2
![alt text](assets/bfs_2.png)
![alt text](assets/bfs_2_2.png)

## BFS Simultion 3
![alt text](assets/bfs_3.png)
![alt text](assets/bfs_3_1.png)
![alt text](assets/bfs_3_2.png)
![alt text](assets/bfs_3_3.png)
![alt text](assets/bfs_3_4.png)

## BFS Simultion 4
### Disconnected Graph : needs to restart from the unvisited disconnected node


# DLS

    - Depth limited search
    - depth first search with a depth limit
    - uses stack (LIFO)
    - avoids going too deep
    - not guaranteed to find the shortest path
    - not complete (if the target is beyond the depth limit)
    - low memory use
    - can be used for pathfinding, topological sorting, and cycle detection with a depth limit

## DLS performance analysis


---
# Comparisons : DFS, BFS, DLS, IDS, UCS 
---

| Feature / Algorithm | **DFS**                        | **BFS**                                  | **DLS**                     | **IDS**                                   | **UCS**                                       |
| ------------------- | ------------------------------ | ---------------------------------------- | --------------------------- | ----------------------------------------- | --------------------------------------------- |
| **Formula**         | DFS = Stack (LIFO)             | BFS = Queue (FIFO)                       | DLS = DFS + Depth Limit     | IDS = Repeated DLS with increasing limit  | UCS = Priority Queue + Lowest Path Cost First |
| **Data Structure**  | Stack (explicit or recursion)  | Queue                                    | Stack + Depth Counter       | Stack + Depth Limit Loop                  | Priority Queue (Min-Heap)                     |
| **Prioritizes**     | Depth first                    | Shallowest depth                         | Depth until limit           | Shallowest depth via repeated DFS         | Lowest total path cost                        |
| **Uses Weights?**   | ❌                              | ❌                                        | ❌                           | ❌                                         | ✅                                             |
| **Completeness**    | No (may loop forever)          | Yes (if finite graph)                    | No (if target beyond limit) | Yes (if finite graph)                     | Yes (positive weights)                        |
| **Optimality**      | No                             | Yes (unweighted)                         | No                          | Yes (unweighted)                          | Yes                                           |
| **Memory Use**      | Low                            | High                                     | Low                         | Low                                       | Moderate                                      |
| **Notes**           | Can get stuck in deep branches | Finds shortest path in unweighted graphs | Avoids going too deep       | Combines BFS completeness with DFS memory | Finds cheapest path in weighted graphs        |


---


Alright — let’s break down the **performance & analysis** for the five search algorithms (DFS, BFS, DLS, IDS, UCS) in terms of **time complexity, space complexity, completeness, and optimality**.

---

| **Criteria**         | **DFS**                                                                       | **BFS**                                                                       | **DLS**                                                                           | **IDS**                                    | **UCS**                            |
| -------------------- | ----------------------------------------------------------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------------------------- | ------------------------------------------ | ---------------------------------- |
| **Time Complexity**  | $O(b^m)$ — explores deep first, where $b$ = branching factor, $m$ = max depth | $O(b^s)$ — explores shallow first, $s$ = depth of shallowest goal/depths/node | $O(b^l)$ — limited by depth limit $l$, $s$ = depth of shallowest goal/depths/node | $O(b^s)$ — repeats DFS up to depth $d$     | Exponential                        |
| **Space Complexity** | $O(b^m)$                                                                      | $O(b^s)$                                                                      | $O(bl)$                                                                           | $O(bs)$                                    | Exponential                        |
| **Completeness**     | NO                                                                            | YES                                                                           | YES (If l >= S)                                                                   | YES                                        | YES                                |
| **Optimality**       | NO                                                                            | YES                                                                           | NO                                                                                | YES (if all edge costs are equal)          | YES                                |
| **When to Use**      | Memory is very limited and solution is likely deep                            | Need shortest path in unweighted graph                                        | Solution within known depth limit                                                 | Depth unknown but memory efficiency needed | Least-cost path in weighted graphs |

---

**Legend**:

* $b$ = branching factor (average number of children per node)
* $d$ = depth of shallowest goal node
* $m$ = maximum depth of graph
* $l$ = depth limit (DLS)
* $C^*$ = cost of optimal solution
* $\epsilon$ = minimum edge cost

---


